# Python 类机制速查手册 
> From ArlesZhang Daily Log

## 今日核心问题 & 答案速查

### 1. PyCharm 指定范围代码折叠（实战优先）
| 方法 | 快捷键（Win/Linux） | 效果 | 永久性 | 推荐场景 |
|------|---------------------|------|--------|----------|
| **临时折叠选中** | `Ctrl + .` | 选中 → 一行折叠（+展开） | 否 | 调试/日志收起（80%场景） |
| **永久 `#region`** | 选中 → `Ctrl+Alt+T` → region...endregion | `#region 标题... #endregion` | 是 | 项目长期维护（设置: Editor → Code Folding → Custom folding regions） |
| **展开/折叠所有** | `Ctrl+Shift +/-` | 全文件 | - | 大文件导航 |

**开箱即用模板**:
```python
# region 数据清洗函数（FuelGenius燃料层）
def clean_data(df): ...
def validate_data(df): ...
# endregion
```

### 2. 类 `__dict__` 核心清单 & 实例→类查找机制
```python
p1 = Person('Arles', 18, '男')
print(p1.__dict__)  # {'name': 'Arles', 'age': 18, 'gender': '男'} ← 实例行李箱
print(Person.__dict__)
# {'__init__': <func>, '__dict__': <descriptor>, ...} ← 类清单（MRO链查找）
```
**关键支柱**:
- `__init__`: 实例化自动调用（构造实例属性）
- `__dict__`: 描述符 → 每个实例独立 `{}`（`p1.name = 'Arles'` 落这里）

**完整 dunder 分类表**（优先级排序，80%够用）:
| 分类 | dunder | 优先级 | 代码切入 | FuelGenius/Cody 场景 |
|------|--------|--------|----------|----------------------|
| 创建销毁 | `__init__` | ★★★★★ | `def __init__(self, name):` | 实例化 Agent/DataCody |
| 实例存储 | `__dict__` | ★★★★★ | `print(obj.__dict__)` | 调试实例状态 |
| 表示 | `__str__`/`__repr__` | ★★★★☆ | `def __repr__(self): return f"Person({self.name})"` | print(Agent) 日志 |
| 比较 | `__eq__` | ★★★★☆ | `def __eq__(self, other):` | 数据去重验证 |
| 容器 | `__len__`/`__getitem__` | ★★★★☆ | `def __len__(self):` | Agent 数据批次 |

**记忆**: 三斧头（`__init__`出生、`__str__`介绍、`__eq__`比较）+ 两钥匙（`__dict__`行李、`__getattr__`动态）。

### 3. 类方法 `@classmethod` vs 工厂方法（本质区分）
**类方法**: 方法类型（`cls` 参数，操作类级数据）  
**工厂方法**: 设计意图（**返回 cls(...) 实例**，替代 `__init__`）

**判断标准**: 有 `return cls(...)` → 工厂；无 → 普通类方法
```python
class Person:
    max_age = 120  # 类属性
    
    @classmethod
    def from_birth_year(cls, name, year):  # 工厂（返回实例）
        return cls(name, 2026-year)  # FuelGenius: from_timestamp(ts)
    
    @classmethod
    def get_max_age(cls):  # 普通类方法（无实例）
        return cls.max_age  # Cody: get_config()

# 继承友好（Student.from_birth_year → Student实例）
```

**@classmethod 非工厂用途表**:
| 用途 | 返回 | 示例 | 项目落地 |
|------|------|------|----------|
| 类属性读写 | int/str | `get_max_age(cls)` | 配置管理 |
| 计数器 | int | `get_next_id(cls)` | DataCody 任务ID |
| 注册子类 | None | `register_subclass(cls, SubAgent)` | FuelGenius 插件 |
| 验证 | bool | `is_valid_data(cls, df)` | 数据校验 |

### 4. 类方法调用误区（代码验证）
```python
class Person:
    def __init__(self, name, age, gender): self.name, self.age, self.gender = name, age, gender
    def speak(self, msg): print(f'{self.name}说: {msg}')

# ❌ 错误1: Person.speak('hi') → TypeError (缺 self)
# ❌ 错误2: Person.speak(self, 'hi') → NameError (self未定义)

# ✅ 正确: 实例调用
p1 = Person('Arles', 18, '男')
p1.speak('Hello')  # 绑定 self=p1

# ✅ 类方法示例（可类/实例调用）
@classmethod
def class_speak(cls, msg): print(f'{cls.__name__}说: {msg}')
Person.class_speak('Hi')  # <class '__main__.Person'>说: Hi
p1.class_speak('Hi')      # 同上（cls=Person）
```
**机制**: 实例方法隐式绑定 `self`；类方法绑定 `cls`。

## 今日收获 Action Items（高强度计划）
- **Day1**: PyCharm 设置 `#region` + 折叠 FuelGenius `clean_data.py` 10段
- **Day2**: 重写 Person 类，加 `__repr__` + 2个工厂（`from_dict`/`from_csv`）→ 测试 Student 继承
- **Week1**: Cody Agent 加 `@classmethod from_dagster_task(cls, task)` 工厂
- **验证**: `print(p1.__dict__)` 每日调试，掌握实例状态

**优先级**: Python 类 → DS&A（LeetCode list/dict）→ LLM Agent（工厂创建 RAG 实例）

## 三个思考题
1. **工厂方法在你的 Agent 项目中如何解耦数据源**？（CSV/Parquet/JSON → `from_xxx(cls)` → FuelGenius 统一燃料）
2. **为什么 `__dict__` 是 Python "行李箱"，Cody 编译器如何用 `__getattr__` 动态加载 Spark DAG**？
3. **类方法 vs 静态方法：FuelGenius 验证函数用哪个？继承时 cls 如何提升 10x 多态**？

> Arles，按这个结构 GitHub commit，今天类机制已落地 90%。明天 FuelGenius 加 3 个工厂方法，手撕 `from_parquet(cls, path)`，你的数据飞轮燃料层就活了！坚韧推进，大厂/商业化近在眼前。Push it! 
