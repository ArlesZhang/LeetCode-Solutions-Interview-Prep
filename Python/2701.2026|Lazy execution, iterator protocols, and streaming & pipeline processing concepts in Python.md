## 按照最高频 → 中频 → 低频、最实用 → 较理论

Python 中**延迟执行（Lazy Evaluation）**、**迭代器协议**与**流式/管道式处理**的思想，是 Python 高效处理大数据、函数式编程风格的核心之一。

从你提到的 `map` 和 `filter` 出发，我们系统地展开这个知识体系。

采用 **总 → 分 → 总** 结构，便于从整体框架到细节掌握，再回到实际应用。

### Python 延迟计算的核心思想与价值（为什么重要？）

Python（尤其是 Python 3）大量采用**惰性求值 + 迭代器协议**，让代码在**不一次性加载所有数据**的情况下完成复杂转换/过滤/聚合。

核心价值总结（5 大优势）：

| 优势      | 说明                                              | 典型场景                 |
| ------- | ----------------------------------------------- | -------------------- |
| 内存效率    | 只在需要时产生下一个元素，不预先计算整个结果列表                        | 处理 GB 级日志、API 分页数据   |
| 惰性计算    | 计算被推迟到真正消费时（next() / for 循环 / list() / sum() 等） | 链式 map/filter/reduce |
| 短路/提前终止 | 一旦下游不需要了，上游就不继续计算（e.g. any(), next() 只取一个）      | 搜索第一个匹配项             |
| 可组合性极强  | 函数返回迭代器 → 可以无限链式组合，像 Unix pipe                  | 数据 ETL 管道            |
| 统一接口    | 几乎所有内置函数/库都支持迭代器协议（for 循环、sum、max、list等）        | 代码复用性高               |

**一句话核心**：  
Python 把“计算结果”从“容器”变成了“生产过程”，把内存负担从“提前全量”变成了“按需生产”。

### Python 中实现延迟/流式处理的主要工具与层次（从基础到高级）

#### 1. 最底层：迭代器协议（Iterator Protocol）

- **Iterable**：有 `__iter__()` 方法，返回 Iterator 的对象（如 list、tuple、str、range、open() 文件）
- **Iterator**：同时有 `__iter__()`（返回自己）和 `__next__()` 方法的对象
- **Generator**：最常见的 Iterator 实现方式，用 `yield` 关键字定义函数

关系图（层次）：
```
对象 → 如果有 __iter__() → Iterable
       ↓
返回的对象 → 如果有 __next__() → Iterator
       ↓
用 yield 写的函数调用后 → Generator（特殊的 Iterator）
```

示例对比（同一功能的不同实现方式）：

```python
# 1. 普通列表（立即计算，全内存）
squares = [x**2 for x in range(10000000)]          # 立即占很大内存

# 2. 生成器表达式（延迟）
squares_gen = (x**2 for x in range(10000000))      # 几乎不占内存

# 3. 生成器函数
def squares_gen_func(n):
    for x in range(n):
        yield x**2

# 4. 迭代器类（手动实现，较少用）
class Squares:
    def __init__(self, n): self.n, self.i = n, 0
    def __iter__(self): return self
    def __next__(self):
        if self.i >= self.n: raise StopIteration
        val = self.i ** 2
        self.i += 1
        return val
```

#### 2. 内置延迟函数（你最熟悉的起点）

| 函数       | 返回类型     | 延迟？ | 主要用途                     | 典型链式用法示例                              |
|------------|--------------|--------|------------------------------|-----------------------------------------------|
| `map()`    | iterator     | 是     | 逐元素变换                   | map(str.upper, filter(...))                   |
| `filter()` | iterator     | 是     | 逐元素筛选                   | filter(is_prime, map(square, range(1, n)))    |
| `zip()`    | iterator     | 是     | 并行迭代多个可迭代对象       | zip(map(...), filter(...))                    |
| `enumerate()` | iterator  | 是     | 带索引迭代                   | enumerate(filter(...))                        |
| `reversed()` | iterator   | 是     | 反向迭代（对支持的类型）     | reversed(filter(...))                         |

#### 3. itertools 模块（流处理神器，推荐掌握）

itertools 提供了大量纯迭代器工具，几乎所有复杂管道都可以用它优雅实现。

| 类别    | 代表函数                                  | 作用简述          | 内存友好度 | 常用场景示例             |
| ----- | ------------------------------------- | ------------- | ----- | ------------------ |
| 无限生成  | count, cycle, repeat                  | 产生无限序列        | ★★★★★ | 模拟时钟、轮询、重试机制       |
| 有限组合  | chain, chain.from_iterable            | 拼接多个迭代器       | ★★★★★ | 合并多个文件/日志          |
| 切片/分组 | islice, takewhile, dropwhile, groupby | 切片、提前终止、按条件分组 | ★★★★★ | 分页读取大文件、按 key 分组   |
| 过滤/选择 | compress, filterfalse                 | 增强 filter     | ★★★★☆ | 多条件掩码过滤            |
| 排列组合  | product, permutations, combinations   | 全排列、组合        | ★★☆☆☆ | 小规模搜索、测试用例生成       |
| 聚合/配对 | accumulate, pairwise, tee             | 累加、成对、复制迭代器   | ★★★★☆ | 累计和、滑动窗口、多次消费同一迭代器 |

经典管道示例（非常 Pythonic）：
```python
from itertools import islice, chain, tee

# 延迟读取大文件的前 1000 个偶数行并转换为 int
with open("huge.log") as f:
    lines = (line.strip() for line in f)                # 延迟打开行
    even_lines = islice(lines, 1, None, 2)              # 从第2行起每隔1行（0-based）
    numbers = map(int, even_lines)
    for num in numbers: ...                             # 只在循环时才真正读文件
```

#### 4. 其他高级/第三方延迟工具（扩展视野）

- **生成器表达式** `(x for x in ...)` → 最常用、最简洁的延迟方式
- **yield from** → 委托子生成器（Python 3.3+）
- **functools.reduce** → 虽然本身不延迟，但常与延迟上游组合
- **more-itertools**（第三方库）→ 提供 sliding_window、chunked、collapse、only 等
- **toolz / cytoolz** → 函数式工具库，强调管道式组合（curry、compose）
- **pandas / polars** → DataFrame 的 lazy 模式（尤其是 polars 的 query optimization）
- **dask / ray** → 分布式延迟计算（大数据场景）
