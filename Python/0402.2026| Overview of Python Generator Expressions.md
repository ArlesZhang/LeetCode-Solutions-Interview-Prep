# Python生成器概述

> Python生成器表达式是一种使用圆括号括起来的、类似于列表推导式的紧凑语法，==用于创建惰性求值的生成器对象==。它不立即生成整个序列并占满内存，而是在迭代时按需（lazy evaluation）计算元素，极大地**节省**了**内存空间**。适用于处理**大规模数据集、单次遍历序列及复杂的序列转换**。 

**1.定义 (Definition)** 

生成器表达式采用 `(expression for item in iterable if condition)` 的形式。

- **语法**：小括号 `()`，内部类似于列表推导式。
- **示例**：`gen = (x**2 for x in range(10))`。
- **返回值**：一个生成器对象（generator object），而非列表。 

**迭代器是为了解决“内存”和“解耦”问题**，手写 `__iter__` 和 `__next__` **过于麻烦**，于是有了**生成器 (Generator)** — 这是一种“**自动档**”的迭代器，它用 `yield` 关键字把这套复杂的机制简化到了极致。
> 1. 生成器函数：函数体中如果出现了 yield 关键字，那该函数是『生成器函数』。
> 2. 生成器对象：调用『生成器函数』时，其函数体不会立刻执行，而是返回一个『生成器对象』(特殊的迭代器)。
> 3. 不管能否执行到 yield 所在的位置，只要函数中有 yield，那该函数就是『生成器函数』。
> 4. 受限制的场景: 实现**斐波那契数列**这种**带复杂逻辑的场景**不适用生成器表达式


**2.作用 (Purpose)** 

- **节省内存（惰性计算）**：与列表推导式 (`[...]`) 不同，生成器表达式一次只生成一个元素，特别适合处理无法一次性装入内存的巨大数据流。
- **提高性能**：减少了创建大列表的时间和内存开销。
- **单次遍历**：通常用于只需要遍历一次的数据序列。 

**3.使用场景 (Use Cases)** 

- **处理大文件或海量数据**：例如逐行读取几GB的日志文件进行处理。
    ```python
    lines = (line.strip() for line in open("huge_log.txt") if "ERROR" in line)
    for error in lines:
        print(error) # 惰性读取，不一次性加载
    ```
    
- **计算序列的和/统计**：用于 `sum()`, `max()`, `min()`, `all()`, `any()` 等聚合函数。
    ```python
    total = sum(x**2 for x in range(10000000)) # 仅在sum计算时逐个生成
    ```
    
- **复杂的单次数据处理**：例如在字典或序列中过滤并映射数据。
    ```python
    data = [1, 2, 3, 4]
    squares = (x*x for x in data if x % 2 == 0)
    # print(list(squares)) # 转换为列表时才求值
    ```

**生成器表达式 vs 列表推导式** 

|特性|生成器表达式 `(x for x in ...)`|列表推导式 `[x for x in ...]`|
|---|---|---|
|**内存占用**|低（按需生成，不占用大内存）|高（一次性创建整个列表）|
|**求值方式**|惰性求值 (Lazy)|立即求值 (Eager)|
|**执行速度**|遍历快，创建快|创建慢（需分配内存）|
|**使用次数**|只能遍历一次|可重复遍历|
**注意事项** 
- **只能被迭代一次**：一旦遍历结束，生成器对象就空了，不能再使用。
- **使用小括号**：如果生成器表达式是函数唯一的参数，可以省略小括号。如：`sum(x**2 for x in range(10))`
