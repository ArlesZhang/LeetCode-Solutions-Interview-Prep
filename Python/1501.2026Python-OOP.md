# Python 学习笔记  
> 主题：魔法方法（Magic Methods / Dunder Methods）与 Python 多态本质

## 今天重点掌握的内容

### 1. 常见魔法方法及其真实含义
- `__str__`    → string representation（人类可读，print / str() 优先调用）
- `__repr__`   → official representation（开发者调试用，repr() / REPL 显示）
- `__len__`    → length（len() 调用）
- `__lt__` / `__gt__` / `__eq__` → rich comparisons（< > ==）
- `__getattr__` → 属性访问失败时的兜底（动态属性）

**关键区别**：  
`__str__` 给用户看（友好、简洁、无引号）  
`__repr__` 给开发者看（准确、可 eval 还原最好）

### 2. 魔法方法的名字是“协议”，不是随意起的
- 必须使用固定的双下划线名字，Python 才会自动调用
- 改名后不会被运算符 / 内置函数触发

### 3. Python 多态的核心（鸭子类型）
- **不需要**强制继承关系
- **只需要**对象拥有同名方法即可互换使用
- 继承的主要价值：语义清晰、可读性、统一接口、类型提示友好

示例（去掉继承也能正常多态）：
```python
def make_sound(thing):
    thing.speak()

class Dog:     def speak(self): print("汪")
class Cat:     def speak(self): print("喵")
class Radio:   def speak(self): print("滴滴滴")

make_sound(Dog())    # 汪
make_sound(Cat())    # 喵
make_sound(Radio())  # 滴滴滴
```

### 4. 常见误区澄清
- `dict(obj)` 不会自动调用 `__dict__`（会报 not iterable）
  → 正确写法：`vars(obj)` 或 `obj.__dict__`
- `len(obj)` 的含义由你决定，不是自动取属性数量
- 类型注解 / 继承在运行时不决定多态行为（仅辅助 IDE / mypy）

## 今日小结一句话
Python 的魔法方法和多态本质上都是“协议 + 名字约定”的体现：  
让自定义类型“像内置类型一样自然使用”，让代码更具表达力，同时保持极高的灵活性。


### Thinking

1. 你觉得在实际项目中，`__str__` 和 `__repr__` 哪个更值得优先实现？为什么？有没有遇到过只实现了其中一个导致调试很痛苦的经历？

2. 如果让你设计一个 `Vector2D` 类，你会让它支持哪些魔法方法（+ - * len [] == < > print 等等）？你会如何权衡“功能全面”和“保持简单”？

3. Python 的“鸭子类型”多态这么自由，你认为它在大型项目中是优势还是隐患？什么时候你会主动加上继承 / 抽象基类 / Protocol 来约束它？
