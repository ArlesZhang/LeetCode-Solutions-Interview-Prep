# Python OOP Design Notes ‚Äî `@property`, Inheritance, and Type Safety

## 1. Why `@property` Matters in Real Projects

In Python, **`@property` is not just syntax sugar**. It is a design tool that protects:

* **Interface stability**
* **Inheritance compatibility (Liskov Substitution Principle)**
* **Type safety and IDE/static checker friendliness**

If an attribute *represents state*, not an action, `@property` is almost always the correct choice.

---

## 2. Inheritance Compatibility (Liskov Substitution Principle)

### ‚ùå Problem: Parent uses method, child switches to `@property`

```python
class Person:
    def age(self) -> int:
        return 18

class Student(Person):
    @property
    def age(self) -> float:
        return 18.5

def print_age(p: Person):
    print(p.age())   # external contract: age is callable

print_age(Student())  # ‚ùå TypeError
```

**Why this breaks**
The *call style* (`p.age()` vs `p.age`) changed.
The subclass is no longer safely substitutable for the parent.

---

### ‚úÖ Solution: Parent uses `@property` from the start

```python
class Person:
    @property
    def age(self) -> int:
        return 18

class Student(Person):
    @property
    def age(self) -> float:
        return 18.5

def print_age(p: Person):
    print(p.age)   # stable interface

print_age(Student())  # ‚úÖ works
```

**Key insight**
`@property` freezes the *external interface* while allowing internal logic to evolve.

---

## 3. Why `@property` Is More Type-Safe

### ‚ùå Ordinary method: type system can‚Äôt protect you

```python
class Person:
    def age(self) -> int:
        return 18

p = Person()
p.age = "25"      # ‚ùå silently allowed
p.age()           # üí• runtime error
```

* IDE sees `age` as a method
* Assignment creates a shadowing instance attribute
* Bug appears late and far from the cause

---

### ‚úÖ `@property`: IDE + type checker understand intent

```python
class Person:
    @property
    def age(self) -> int:
        return self._age

    @age.setter
    def age(self, value: int):
        if value < 0:
            raise ValueError("age must be positive")
        self._age = value
```

Benefits:

* IDE knows `age` is an `int`
* Static checkers can flag `p.age = "25"`
* Runtime validation is centralized and explicit

---

## 4. Design Rule of Thumb

| If a member represents‚Ä¶                                  | Use         |
| -------------------------------------------------------- | ----------- |
| Action / behavior                                        | method      |
| State / configuration                                    | `@property` |
| Value that may gain validation, logging, unit conversion | `@property` |
| Public API meant to be overridden by subclasses          | `@property` |

**In short:**

> Methods express *verbs*.
> `@property` expresses *nouns with rules*.

---

## 5. Why This Matters in Real Systems

In large systems (configs, workflows, agents, ML pipelines):

* Interfaces must remain stable
* Subclasses must be safely interchangeable
* IDEs and static tools must help, not guess

`@property` is a **future-proofing mechanism**, not a style preference.

---

## Three Questions to Reflect On / Discuss with Your Audience

1. **Which fields in your current project look ‚Äúsimple today‚Äù but might need validation or transformation tomorrow?**
2. **Have you ever broken downstream code by changing a method‚Äôs call style without realizing it?**
3. **If Python were statically typed by default, which of your current bugs would disappear immediately?**

