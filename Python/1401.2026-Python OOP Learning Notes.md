# Python OOP Learning Notes

## Key Topics Covered Today

### 1. super() in Python 3
- Correct & recommended: `super().__init__(args...)`
- No need to write `super().__init__(self, ...)`
- Python 3 zero-argument `super()` automatically passes the instance (`self`)

### 2. isinstance() vs issubclass()
Both are **built-in functions** — no import needed.

```python
isinstance(obj, Class)      # True if obj is instance of Class or subclass
issubclass(Sub, Super)      # True if Sub inherits from Super (directly or indirectly)
```

Common related built-ins: `type()`, `hasattr()`, `getattr()`, `setattr()`, `super()`, `callable()`

### 3. Bound Method vs Function
```python
print(type(s1))          # <class '__main__.Student'>
print(type(s1.spark))    # <class 'method'>
print(s1.spark)          # <bound method Student.spark of <Student object at ...>>
```

- `Student.spark` → function
- `s1.spark` → bound method (instance is already bound as `self`)
- Calling `s1.spark()` automatically passes `s1` as `self`

### 4. Multiple Inheritance – Common Pitfalls
```python
class Student(Person, Work):
    def __init__(self, name, age, gender, company, stu_id, grade):
        Person.__init__(self, name, age, gender)
        Work.__init__(self,company) 
       # Work.__inti__(self, company)   # ← Error here init not inti (spelling mistake)
       # super().__init__(company)    # ← Error here
        ...
```

**Main bugs found:**
- Typo: `__inti__` should be `__init__`
- Even after fix, better style in Python 3: use `super()` instead of hard-coding parent names
  → avoids MRO problems in complex diamond inheritance

**Recommended modern style:**
```python
super().__init__(name, age, gender)           # calls Person
super(Person, self).__init__(company)         # calls next in MRO (Work)
# or (cleanest if no conflict): super().__init__(company)
```

## Summary – Today's Biggest Takeaways
- Prefer `super()` zero-argument form in Python 3
- `isinstance` respects inheritance, `type` does not
- Instance methods become **bound methods** when accessed via instance
- In multiple inheritance, prefer `super()` over explicit parent calls


### Three thoughts to ponder / share with your followers

1. **Which do you personally prefer in 2025 — explicit parent calls (`Person.__init__(self, ...)`) or `super()` — and why?**  
   (Many senior devs still argue about readability vs safety in large codebases.)

2. **Have you ever been bitten by multiple inheritance + wrong `__init__` order?**  
   What was the weirdest bug you saw? (MRO surprises make great horror stories.)

3. **Python gives us both power tools (`super`, bound methods, descriptors) and sharp edges.**  
   Do you think this makes Python more “adult” as a language, or just unnecessarily complicated compared to simpler OO languages?
