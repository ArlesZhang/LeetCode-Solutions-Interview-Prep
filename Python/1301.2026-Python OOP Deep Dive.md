# Python OOP Deep Dive – Jan 13, 2026

## Today's Key Takeaways

### 1. `__init__` is **not** a normal method
- It is the **initializer** called automatically during instance creation.
- When a subclass defines its own `__init__`, it **completely overrides** the parent's `__init__`.
- Python **does **not** automatically call the parent's `__init__` or try to match parameters.
- **Rule**: If subclass has `__init__`, you **must** pass exactly the parameters the subclass expects (except `self`).
- To reuse parent initialization → must **explicitly** call `super().__init__(...)` or `Parent.__init__(self, ...)`.

### 2. Method overriding vs. `__init__` overriding
| Feature               | Normal methods (e.g. `spark`)          | `__init__`                              |
|-----------------------|----------------------------------------|-----------------------------------------|
| Override behavior     | Child version hides parent             | Child completely replaces parent        |
| Can call parent?      | Yes – `super().method()`               | Yes – but **must** write it yourself    |
| Parameter flexibility | Can be different                       | Must match exactly what child declares  |
| Auto fallback?        | Yes (MRO lookup)                       | **No** – strict match or TypeError      |

### 3. Common patterns seen today
```python
class Person:
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender

    def spark(self, msg):
        print(f"我叫{self.name}, 年龄{self.age}, 性别{self.gender}, 我想说{msg}")

class Student(Person):
    def __init__(self, name, age, gender, score, grade):
        super().__init__(name, age, gender)           # ← must call explicitly
        self.score = score
        self.grade = grade

    def spark(self, msg):
        super().spark(msg)                            # call parent version
        print(f"我是学生, 成绩{self.score}分, 想说: {msg}")
```

### Mistakes that caused confusion today
- Writing `__int__` instead of `__init__` → never called
- Expecting Python to “fall back” to parent `__init__` when parameters don’t match → **it doesn’t**
- Thinking instance creation is “flexible” and can omit parameters → only true if subclass has **no** `__init__`

## Three thoughts to ponder / share with followers

1. **显式优于隐式**真的体现在哪里？  
   Python 为什么宁可让你写 `super().__init__()` 也不愿意偷偷帮你调用父类构造？这种设计在实际项目中帮你避免了哪些隐藏 bug？

2. “覆盖” vs “扩展”的边界在哪里？  
   当你重写一个方法时，你是想完全替代父类行为，还是想在父类行为基础上“加料”？你更倾向哪种风格？为什么？

3. **构造方法的参数应该有多“严格”？**  
   如果允许子类构造时随意少传参数，会让代码更灵活，还是更容易制造出“半初始化”的危险对象？你在实际项目中会更倾向哪一边？
