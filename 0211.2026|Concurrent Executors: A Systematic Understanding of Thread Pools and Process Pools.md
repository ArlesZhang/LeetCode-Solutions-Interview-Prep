
# 并发执行器：线程池与进程池的系统理解

线程池 / 进程池解决的本质问题只有一个：  
「**我不想自己管理线程/进程的生命周期，但我想并发执行任务，并在未来某个时刻拿到结果**」。
> 1. **诞生 (Initialization)**：`ProcessPoolExecutor` 招募工人。
> 2. **派单 (Dispatching)**：
>     - 主线程执行 `submit` 或 `map`（**主线程在跑，非阻塞**）。
>     - 主线程拿到了 `Future` 对象（收据）。
> 3. **执行 (Execution)**：
>     - 子进程在后台疯狂计算（**真正的并发发生在这里**）。
> 4. **收割 (Harvesting) —— 你纠结的“卡住”环节**：
>     - **方式 1：我急用。** 执行 `f.result()`（**主线程卡住**，等这一个）。
>     - **方式 2：我按序用。** 迭代 `map`（**主线程卡住**，按 1,2,3 排队等）。
>     - **方式 3：谁好我用谁。** 迭代 `as_completed`（**主线程卡住**，谁好谁弹出来）。
>     - **方式 4：我没空理它。** 使用 `add_done_callback`（**主线程不卡**，任务完工后自行收尾）。
> 5. **离场 (Teardown)**：`with` 代码块结束（**主线程卡住**，等所有工人下班关灯）。


该原理的解释详见[[进程-阻塞拆解]] 其中,包含**进程阻塞**和 **add_done_callback** 等关键知识详解:
> - 你启动了**主进程**。
> - 主进程里的**主线程**执行了 `submit`。
> - **子进程**在后台开始苦干。
> - **主线程**执行到 `.result()`，“死死==卡==在那一行”。
> - 此时，**主进程**表现为“等待状态”。
> - **子进程**完工，把结果通过“**管道（IPC）**”传回给主进程。
> - **主线程**收到结果，瞬间“解穴”，继续跑剩下的代码。

1.**阻塞**是当你执行 `f1.result()` 卡住主线程时：
- **主线程**：像是在睡觉，不消耗 CPU，只是在等通知。
- **子进程 1**：正在满负荷跑任务 1（它是主线程等待的对象）。
- **子进程 2、3、4**：**它们并没有停！** 它们依然在后台疯狂跑任务 2、3、4。

**“阻塞”对不同层级的影响**:

|**层级**|**状态**|**详细描述**|
|---|---|---|
|**主线程**|**阻塞 (Blocked)**|它正在调用操作系统的 `wait` 或 `event.wait`，停止执行后续字节码。|
|**主进程**|**存活但停滞**|进程依然在内存里，但因为它唯一的干活人（主线程）在等结果，所以它不产生新的 CPU 计算。|
|**子进程**|**活跃 (Active)**|它们在完全不同的 CPU 核心上跑。主进程的卡顿完全不影响子进程的计算速度。|

2.**add_done_callback** 的详解:
- **如果你想在主程序里“亲手”处理结果**（比如：把所有结果求和打印）：你必须接受主程序会“**停**”下来（用 `result` / `map` / `as_completed`）。 
- **如果你想让主程序完全解脱出来**（比如：后台悄悄下载，好了自己弹窗）：你就用 `callback`，主程序会“**一直跑**”。
> [!TIP] LeetCode 和项目实战方向 : 异步通信的本质
> 1. 通过处理“子进程死锁”、“内存泄露”、“IPC 通信限制”等真实的坑来闭环这部分知识
> 2. Lock Rlock and GIL 锁
